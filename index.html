<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataDome Picasso Canvas Fingerprint Collector - Complete</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; font-family: monospace; }
        .canvas-container { margin: 20px 0; }
        canvas { border: 1px solid #ccc; margin: 10px; }
        .input-container { margin: 20px 0; }
        input { padding: 5px; margin: 5px; }
    </style>
</head>
<body>
    <h1>DataDome Picasso Canvas Fingerprint Collector - Complete Implementation</h1>
    
    <div class="input-container">
        <label>Seed: <input type="number" id="seedInput" value="3" min="1" max="9"></label>
        <label>Shapes: <input type="number" id="shapesInput" value="7" min="0" max="10"></label>
        <button onclick="generateWithInputs()" style="padding: 5px 10px;">Generate with Custom Seed</button>
    </div>
    
    <div class="canvas-container">
        <h3>Dynamic Canvas (from PRNG)</h3>
        <canvas id="dynamicCanvas" width="280" height="155"></canvas>
    </div>
    
    <div class="result">
        <h3>Results:</h3>
        <div id="results">Enter seed and click generate...</div>
    </div>
    
    <button onclick="testAllKnownSeeds()" style="padding: 10px 20px; font-size: 16px;">Test All Known Seeds (1-9)</button>

    <script>
        // DataDome's exact PRNG parameters (need to find these values)
        const PRNG_PARAMS = {
            g: 2147483647,  // Large prime (common for LCG)
            r: 16807        // Common multiplier for LCG  
        };

        // Hash functions from DataDome
        function hashData(data) {
            return crypto.subtle.digest("SHA-256", data).then(function(hash) {
                return Array.from(new Uint8Array(hash));
            });
        }

        function toHex(bytes) {
            return bytes.map(function(byte) {
                return byte.toString(16).padStart(2, "0");
            }).join("");
        }

        // DataDome's PRNG implementation
        function PRNG(seed) {
            this.currentNumber = seed % PRNG_PARAMS.g;
            if (this.currentNumber <= 0) {
                this.currentNumber += PRNG_PARAMS.g;
            }
        }

        PRNG.prototype.getNext = function() {
            this.currentNumber = Math.max(PRNG_PARAMS.r * this.currentNumber % PRNG_PARAMS.g, 2);
            return this.currentNumber;
        };

        // Utility function for scaling random values
        function scaleRandom(rng, maxValue, isFloat) {
            const normalized = (rng.getNext() - 1) / PRNG_PARAMS.g;
            return isFloat ? normalized * maxValue : Math.floor(normalized * maxValue);
        }

        // Color palette from DataDome
        const colors = ["#FF6633", "#FFB399", "#FF33FF", "#FFFF99", "#00B3E6", "#E6B333", "#3366E6", "#999966", "#99FF99", "#B34D4D", "#80B300", "#809900", "#E6B3B3", "#6680B3", "#66991A", "#FF99E6", "#CCFF1A", "#FF1A66", "#E6331A", "#33FFCC", "#66994D", "#B366CC", "#4D8000", "#B33300", "#CC80CC", "#66664D", "#991AFF", "#E666FF", "#4DB3FF", "#1AB399", "#E666B3", "#33991A", "#CC9999", "#B3B31A", "#00E680", "#4D8066", "#809980", "#E6FF80", "#1AFF33", "#999933", "#FF3380", "#CCCC00", "#66E64D", "#4D80CC", "#9900B3", "#E64D66", "#4DB380", "#FF4D4D", "#99E6E6", "#6666FF"];

        // Drawing functions from DataDome  
        const drawingFunctions = [
            // Function 0: Arc
            function(rng, ctx, canvas) {
                ctx.beginPath();
                ctx.arc(
                    scaleRandom(rng, canvas.width / 2),
                    scaleRandom(rng, canvas.height / 2), 
                    scaleRandom(rng, Math.min(canvas.width / 4, canvas.height / 4)),
                    scaleRandom(rng, 2 * Math.PI, true),
                    scaleRandom(rng, 2 * Math.PI, true)
                );
                ctx.stroke();
            },
            // Function 1: Text  
            function(rng, ctx, canvas) {
                const length = Math.max(1, scaleRandom(rng, 5));
                let text = "";
                for (let i = 0; i < length; i++) {
                    const charCode = 65 + rng.getNext() % (126 - 65);
                    text += String.fromCharCode(charCode);
                }
                ctx.font = (canvas.height / 10) + "px aafakefontaa";
                ctx.fillText(text, scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height), scaleRandom(rng, canvas.width));
            },
            // Function 2: Bezier curve
            function(rng, ctx, canvas) {
                ctx.beginPath();
                ctx.moveTo(scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height));
                ctx.bezierCurveTo(
                    scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height),
                    scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height), 
                    scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height)
                );
                ctx.stroke();
            },
            // Function 3: Quadratic curve
            function(rng, ctx, canvas) {
                ctx.beginPath();
                ctx.moveTo(scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height));
                ctx.quadraticCurveTo(
                    scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height),
                    scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height)
                );
                ctx.stroke();
            }
        ];

        // Special emoji function (called when shapes=1)
        function drawEmojiText(rng, ctx, canvas) {
            const num = Math.max(1, scaleRandom(rng, 5));
            const text = "\ufeff▶️" + num;
            ctx.font = (canvas.height / 10) + "px aafakefontaa";
            ctx.fillText(text, scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height), scaleRandom(rng, canvas.width));
        }

        function renderDynamicCanvas(canvas, ctx, seed, shapes) {
            canvas.width = 280;
            canvas.height = 155;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const rng = new PRNG(seed);
            
            // Create radial gradient (always done first)
            const gradient = ctx.createRadialGradient(
                scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height), scaleRandom(rng, canvas.width),
                scaleRandom(rng, canvas.width), scaleRandom(rng, canvas.height), scaleRandom(rng, canvas.width)
            );
            gradient.addColorStop(0, colors[scaleRandom(rng, colors.length)]);
            gradient.addColorStop(1, colors[scaleRandom(rng, colors.length)]);
            ctx.fillStyle = gradient;
            
            // Set shadow
            ctx.shadowBlur = scaleRandom(rng, 20); // maxShadowBlur estimate
            ctx.shadowColor = colors[scaleRandom(rng, colors.length)];
            
            // Select and execute drawing function based on shapes
            let drawFunc;
            if (shapes === 1) {
                drawFunc = drawEmojiText;
            } else {
                drawFunc = drawingFunctions[scaleRandom(rng, drawingFunctions.length)];
            }
            
            drawFunc(rng, ctx, canvas);
            ctx.fill();
            
            return canvas.toDataURL();
        }

        async function generateWithInputs() {
            const seed = parseInt(document.getElementById('seedInput').value);
            const shapes = parseInt(document.getElementById('shapesInput').value);
            
            await generateFingerprint(seed, shapes);
        }

        async function generateFingerprint(seed = 3, shapes = 7) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `Generating fingerprint for seed=${seed}, shapes=${shapes}...<br>`;
            
            try {
                // Create the 3 canvases like DataDome Worker does
                const textCanvas = document.createElement('canvas');
                const dynamicCanvas = document.getElementById('dynamicCanvas');
                const geometricCanvas = document.createElement('canvas');
                
                // Text canvas (380x55) - like Worker first canvas
                textCanvas.width = 380;
                textCanvas.height = 55;
                const textCtx = textCanvas.getContext('2d');
                textCtx.textBaseline = "alphabetic";
                textCtx.fillStyle = "#F0A";
                textCtx.fillRect(49, 1, 73, 25);
                const text = "Quartz glyph job vexd cwm finks" + String.fromCharCode(55357, 56898);
                textCtx.fillStyle = "#3A1";
                textCtx.font = '13pt "Times New Roman"';
                textCtx.fillText(text, 5, 17);
                textCtx.fillStyle = "rgba(49, 40, 223, 0.33)";
                textCtx.font = "17pt Arial";
                textCtx.fillText(text, 7, 25);
                
                // Dynamic canvas (seed-driven) - this replaces the static geometric canvas
                renderDynamicCanvas(dynamicCanvas, dynamicCanvas.getContext('2d'), seed, shapes);
                
                // Get image data from both canvases
                const textImageData1 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                const textImageData2 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height); // Same data
                const dynamicImageData = dynamicCanvas.getContext('2d').getImageData(0, 0, dynamicCanvas.width, dynamicCanvas.height);
                
                // Hash all three like DataDome Worker
                const [textHash1, textHash2, dynamicHash] = await Promise.all([
                    hashData(textImageData1.data),
                    hashData(textImageData2.data),
                    hashData(dynamicImageData.data)
                ]);
                
                // Check stability (DataDome logic)
                const ch = toHex(textHash1) !== toHex(textHash2) ? "UNST" : "stable";
                
                // XOR first text hash with dynamic hash (DataDome logic)
                const pcsoBytes = textHash1.map((byte, index) => byte ^ dynamicHash[index]);
                const pcso = toHex(pcsoBytes);
                
                // Check against known hashes
                const knownHashes = [
                    "131bd7b5e8f9221c94eb742406b4b47e", "86e105b55c457847c7234ed570e925fe",
                    "39114cf3b63d8af324af9c111ba0ea05", "89e095e6a52cc387edd991d82cca2cdc", 
                    "24441bba25a6e2916b4eaf01448ec1fa", "70410ed014ce6c7378228456d621ddfd",
                    "5486f35f2af0574912576b7e5263a912", "cf03d4d6dc719e59acb1671dc0263e2e",
                    "4672bc1c135b989dd64f9fb7ed68e729", "a52d3ff1605eff146016a8a00dd1d5f1"
                ];
                
                const isMatch = knownHashes.includes(pcso);
                
                resultsDiv.innerHTML += `
                    <strong>Seed:</strong> ${seed}<br>
                    <strong>Shapes:</strong> ${shapes}<br>
                    <strong>ch:</strong> ${ch}<br>
                    <strong>pcso:</strong> ${pcso} ${isMatch ? '🎯 MATCH!' : ''}<br>
                    <strong>Text Hash 1:</strong> ${toHex(textHash1).substring(0, 32)}...<br>
                    <strong>Dynamic Hash:</strong> ${toHex(dynamicHash).substring(0, 32)}...<br><br>
                `;
                
                if (isMatch) {
                    console.log(`🎯 COLLISION! Seed ${seed}, Shapes ${shapes}: pcso=${pcso}`);
                }
                
                return isMatch;
                
            } catch (error) {
                resultsDiv.innerHTML += 'Error: ' + error.message + '<br>';
                console.error('Fingerprint generation error:', error);
                return false;
            }
        }

        async function testAllKnownSeeds() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 'Testing all seeds 1-9 with shapes=7...<br><br>';
            
            let matches = 0;
            
            for (let seed = 1; seed <= 9; seed++) {
                const isMatch = await generateFingerprint(seed, 7);
                if (isMatch) matches++;
                await new Promise(resolve => setTimeout(resolve, 200)); // Delay for visibility
            }
            
            resultsDiv.innerHTML += `<br><strong>Completed testing seeds 1-9. Found ${matches} matches!</strong>`;
            
            if (matches === 0) {
                resultsDiv.innerHTML += `<br><em>No matches found. The PRNG parameters (g=${PRNG_PARAMS.g}, r=${PRNG_PARAMS.r}) might be incorrect.</em>`;
            }
        }

        // Auto-generate on page load
        window.addEventListener('load', function() {
            setTimeout(() => generateFingerprint(3, 7), 100);
        });
    </script>
</body>
</html>

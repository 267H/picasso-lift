<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataDome Picasso Canvas Fingerprint Collector</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; font-family: monospace; }
        .canvas-container { margin: 20px 0; }
        canvas { border: 1px solid #ccc; margin: 10px; }
    </style>
</head>
<body>
    <h1>DataDome Picasso Canvas Fingerprint Collector</h1>
    
    <div class="canvas-container">
        <h3>Text Canvas (380x55)</h3>
        <canvas id="textCanvas" width="380" height="55"></canvas>
        
        <h3>Geometric Canvas (131x115)</h3>
        <canvas id="geometricCanvas" width="131" height="115"></canvas>
    </div>
    
    <div class="result">
        <h3>Results:</h3>
        <div id="results">Click "Generate Fingerprint" to start...</div>
    </div>
    
    <button onclick="generateFingerprint()" style="padding: 10px 20px; font-size: 16px;">Generate Fingerprint</button>
    <button onclick="runCollisionTest()" style="padding: 10px 20px; font-size: 16px; margin-left: 10px;">Run Collision Test (100x)</button>

    <script>
        // Exact functions from DataDome's Worker blob
        function hashData(data) {
            return crypto.subtle.digest("SHA-256", data).then(function(hash) {
                return Array.from(new Uint8Array(hash));
            });
        }

        function toHex(bytes) {
            return bytes.map(function(byte) {
                return byte.toString(16).padStart(2, "0");
            }).join("");
        }

        // Exact text canvas rendering from DataDome
        function renderTextCanvas(canvas, ctx) {
            canvas.width = 380;
            canvas.height = 55;
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#F0A";
            ctx.fillRect(49, 1, 73, 25);
            
            var text = "Quartz glyph job vexd cwm finks" + String.fromCharCode(55357, 56898);
            ctx.fillStyle = "#3A1";
            ctx.font = '13pt "Times New Roman"';
            ctx.fillText(text, 5, 17);
            ctx.fillStyle = "rgba(49, 40, 223, 0.33)";
            ctx.font = "17pt Arial";
            ctx.fillText(text, 7, 25);
        }

        // Exact geometric canvas rendering from DataDome
        function renderGeometricCanvas(canvas, ctx) {
            canvas.width = 131;
            canvas.height = 115;
            ctx.globalCompositeOperation = "multiply";
            
            var circles = [["#E3E", 55, 55], ["#3EE", 95, 55], ["#EE3", 70, 90]];
            for (var i = 0; i < circles.length; i++) {
                ctx.fillStyle = circles[i][0];
                ctx.beginPath();
                ctx.arc(circles[i][1], circles[i][2], 45, 0, 2 * Math.PI, true);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.fillStyle = "#EA3";
            ctx.arc(65, 65, 65, 0, 2 * Math.PI, true);
            ctx.arc(65, 65, 30, 0, 2 * Math.PI, true);
            ctx.fill("evenodd");
        }

        // EXACT functions from DataDome Worker blob
        function hashData(t) {
            return crypto.subtle.digest("SHA-256", t).then(function(t) {
                return Array.from(new Uint8Array(t));
            });
        }

        function toHex(t) {
            return t.map(function(t) {
                return t.toString(16).padStart(2, "0");
            }).join("");
        }

        // EXACT text canvas rendering from Worker
        function renderTextCanvas(t, e) {
            t.width = 380;
            t.height = 55;
            e.textBaseline = "alphabetic";
            e.fillStyle = "#F0A";
            e.fillRect(49, 1, 73, 25);
            var n = "Quartz glyph job vexd cwm finks" + String.fromCharCode(55357, 56898);
            e.fillStyle = "#3A1";
            e.font = '13pt "Times New Roman"';
            e.fillText(n, 5, 17);
            e.fillStyle = "rgba(49, 40, 223, 0.33)";
            e.font = "17pt Arial";
            e.fillText(n, 7, 25);
        }

        // EXACT geometric canvas rendering from Worker
        function renderGeometricCanvas(t, e) {
            t.width = 131;
            t.height = 115;
            e.globalCompositeOperation = "multiply";
            for (var n = [["#E3E", 55, 55], ["#3EE", 95, 55], ["#EE3", 70, 90]], a = 0; a < n.length; a++) {
                e.fillStyle = n[a][0];
                e.beginPath();
                e.arc(n[a][1], n[a][2], 45, 0, 2 * Math.PI, !0);
                e.closePath();
                e.fill();
            }
            e.fillStyle = "#EA3";
            e.arc(65, 65, 65, 0, 2 * Math.PI, !0);
            e.arc(65, 65, 30, 0, 2 * Math.PI, !0);
            e.fill("evenodd");
        }

        async function generateFingerprint() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 'Generating EXACT DataDome fingerprint...';
            
            try {
                const textCanvas = document.getElementById('textCanvas');
                const geometricCanvas = document.getElementById('geometricCanvas');
                const textCtx = textCanvas.getContext('2d');
                const geometricCtx = geometricCanvas.getContext('2d');
                
                // EXACT Worker rendering
                renderTextCanvas(textCanvas, textCtx);
                renderGeometricCanvas(geometricCanvas, geometricCtx);
                
                // EXACT Worker logic
                var r = [];
                var l = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                r.push(hashData(l.data));
                var f = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                r.push(hashData(f.data));
                var g = geometricCtx.getImageData(0, 0, geometricCanvas.width, geometricCanvas.height);
                r.push(hashData(g.data));
                
                const hashResults = await Promise.all(r);
                
                // EXACT Worker final logic
                var a = toHex(hashResults[0]) != toHex(hashResults[1]);
                var finalResult = hashResults[0].map(function(t, index) {
                    return t ^ hashResults[2][index];
                });
                
                const ch = a ? "UNST" : "stable";
                const pcso = toHex(finalResult.slice(0, 16)); // Truncate to 128 bits
                
                const knownHashes = [
                    "131bd7b5e8f9221c94eb742406b4b47e", "86e105b55c457847c7234ed570e925fe",
                    "39114cf3b63d8af324af9c111ba0ea05", "89e095e6a52cc387edd991d82cca2cdc"
                ];
                
                const isMatch = knownHashes.includes(pcso);
                
                resultsDiv.innerHTML = `
                    <strong>ch:</strong> ${ch}<br>
                    <strong>pcso:</strong> ${pcso} ${isMatch ? '🎯' : ''}<br>
                    <strong>Match:</strong> ${isMatch ? 'YES' : 'NO'}<br>
                    <strong>Text Hash 1:</strong> ${toHex(hashResults[0]).substring(0, 32)}...<br>
                    <strong>Text Hash 2:</strong> ${toHex(hashResults[1]).substring(0, 32)}...<br>
                    <strong>Geometric Hash:</strong> ${toHex(hashResults[2]).substring(0, 32)}...
                `;
                
                console.log('Results:', { ch, pcso, isMatch });
                
            } catch (error) {
                resultsDiv.innerHTML = 'Error: ' + error.message;
                console.error('Error:', error);
            }
        }

        // Known DataDome hashes for collision testing
        const knownHashes = [
            "131bd7b5e8f9221c94eb742406b4b47e", "86e105b55c457847c7234ed570e925fe",
            "39114cf3b63d8af324af9c111ba0ea05", "89e095e6a52cc387edd991d82cca2cdc", 
            "24441bba25a6e2916b4eaf01448ec1fa", "70410ed014ce6c7378228456d621ddfd",
            "5486f35f2af0574912576b7e5263a912", "cf03d4d6dc719e59acb1671dc0263e2e",
            "4672bc1c135b989dd64f9fb7ed68e729", "a52d3ff1605eff146016a8a00dd1d5f1",
            "0cf0f9a0da87810220afb839d17f74e2", "17fb98a69e516e34e960f4341bac31ed",
            "71a8c093f45196f2d410de7876b236fc", "8f84d86b9158dbf15d5437bc21092799",
            "297456eaa17442feff9533a7225bfce1", "da8c070dfb173b6a49b66b92f7c111f5",
            "0e0c752173a1dadcd6e8916df7a96dd3", "cb5d6bd6cdc4d8d15ca6dc382e8fc959",
            "0d06aa7ee1c84b08e5b82f180109600f", "b82fb81f9ebdb674059b7417f2e6aea7",
            "570bac3d71aede85ea1de7f21a353fae", "d18f65c302f908c9a49e77f0a471f58a",
            "47bcd2ab1356745c729ccc91133ff5b1", "ca2446e997de712792d5c8bea5740472",
            "a27e44c52234700af6b04825e78f82c1", "ca9a49dbabc48f9e02c66117700a5b40",
            "e6acb86ca2766314aacb8f3fe3fb07d6", "39a957a920b2546289421ee1d98b19c4",
            "8610afe1f088c8186ee34b1a8e3b80f4", "3868d536d2e5fd3ef2272b3cc394debf",
            "ddb7c711d42b35c7ec2fc6b47551adee"
        ];

        async function runCollisionTest() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 'Running collision test (100 iterations)...<br><br>';
            
            const generatedHashes = [];
            let matches = 0;
            let uniqueHashes = new Set();
            
            for (let i = 0; i < 100; i++) {
                try {
                    const textCanvas = document.getElementById('textCanvas');
                    const geometricCanvas = document.getElementById('geometricCanvas');
                    const textCtx = textCanvas.getContext('2d');
                    const geometricCtx = geometricCanvas.getContext('2d');
                    
                    renderTextCanvas(textCanvas, textCtx);
                    const textImageData1 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                    const textImageData2 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                    
                    renderGeometricCanvas(geometricCanvas, geometricCtx);
                    const geometricImageData = geometricCtx.getImageData(0, 0, geometricCanvas.width, geometricCanvas.height);
                    
                    const [textHash1, textHash2, geometricHash] = await Promise.all([
                        hashData(textImageData1.data),
                        hashData(textImageData2.data), 
                        hashData(geometricImageData.data)
                    ]);
                    
                    const isUnstable = toHex(textHash1) !== toHex(textHash2);
                    const finalHash = textHash1.map((byte, index) => byte ^ geometricHash[index]);
                    const hexFinalHash = toHex(finalHash);
                    
                    generatedHashes.push({
                        pcso: hexFinalHash,
                        stable: !isUnstable,
                        textHash1: toHex(textHash1),
                        textHash2: toHex(textHash2),
                        geometricHash: toHex(geometricHash),
                        iteration: i + 1
                    });
                    uniqueHashes.add(hexFinalHash);
                    
                    // Check if this hash matches any known DataDome hash
                    if (knownHashes.includes(hexFinalHash)) {
                        matches++;
                        console.log(`🎯 COLLISION FOUND! Iteration ${i+1}: ${hexFinalHash}`);
                    }
                    
                    // Debug output every 10 iterations
                    if ((i + 1) % 10 === 0) {
                        resultsDiv.innerHTML += `Completed ${i+1}/100 iterations. Matches so far: ${matches}<br>`;
                        console.log(`Iteration ${i+1}:`, {
                            pcso: hexFinalHash,
                            stable: !isUnstable,
                            textHash1: toHex(textHash1).substring(0, 16) + '...',
                            textHash2: toHex(textHash2).substring(0, 16) + '...',
                            geometricHash: toHex(geometricHash).substring(0, 16) + '...'
                        });
                    }
                } catch (error) {
                    console.error(`Error in iteration ${i+1}:`, error);
                }
            }
            
            // Calculate statistics
            const collisionRate = (matches / 100) * 100;
            const uniqueCount = uniqueHashes.size;
            const expectedCollisionProbability = (31 / Math.pow(16, 32)) * 100; // Theoretical
            
            resultsDiv.innerHTML += `
                <br><h3>Collision Test Results:</h3>
                <strong>Matches with known DataDome hashes:</strong> ${matches}/100 (${collisionRate.toFixed(1)}%)<br>
                <strong>Unique hashes generated:</strong> ${uniqueCount}/100<br>
                <strong>Collision rate:</strong> ${((100 - uniqueCount) / 100 * 100).toFixed(1)}% (self-collisions)<br>
                <br>
                ${matches > 0 ? 
                    '<span style="color: green; font-weight: bold;">✅ SUCCESS: Implementation verified by hash collision!</span>' : 
                    '<span style="color: orange;">⚠️ No collisions found - may need more iterations or algorithm differences</span>'}
                <br><br>
                <strong>Sample of generated data (first 5):</strong><br>
                <div style="max-height: 300px; overflow-y: scroll; font-size: 11px; background: #f8f8f8; padding: 10px;">
                    ${generatedHashes.slice(0, 5).map(item => 
                        `<strong>Iteration ${item.iteration}:</strong><br>
                         - PCSO: ${item.pcso} ${knownHashes.includes(item.pcso) ? '🎯' : ''}<br>
                         - Stable: ${item.stable ? 'YES (problem!)' : 'NO (correct)'}<br>  
                         - Text Hash 1: ${item.textHash1.substring(0, 32)}...<br>
                         - Text Hash 2: ${item.textHash2.substring(0, 32)}...<br>
                         - Geometric: ${item.geometricHash.substring(0, 32)}...<br>
                         - Hashes Match: ${item.textHash1 === item.textHash2 ? 'YES (wrong!)' : 'NO (correct)'}<br><br>`
                    ).join('')}
                    <strong>Unique PCSO values:</strong> ${Array.from(new Set(generatedHashes.map(h => h.pcso))).length}<br>
                    <strong>First PCSO:</strong> ${generatedHashes.length > 0 ? generatedHashes[0].pcso : 'none'}
                </div>
            `;
        }

        // Auto-generate on page load for convenience
        window.addEventListener('load', function() {
            setTimeout(generateFingerprint, 100);
        });
    </script>
</body>
</html>

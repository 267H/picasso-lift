<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataDome Picasso Canvas Fingerprint Collector</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .result { background: #f0f0f0; padding: 10px; margin: 10px 0; font-family: monospace; }
        .canvas-container { margin: 20px 0; }
        canvas { border: 1px solid #ccc; margin: 10px; }
    </style>
</head>
<body>
    <h1>DataDome Picasso Canvas Fingerprint Collector</h1>
    
    <div class="canvas-container">
        <h3>Text Canvas (380x55)</h3>
        <canvas id="textCanvas" width="380" height="55"></canvas>
        
        <h3>Geometric Canvas (131x115)</h3>
        <canvas id="geometricCanvas" width="131" height="115"></canvas>
    </div>
    
    <div class="result">
        <h3>Results:</h3>
        <div id="results">Click "Generate Fingerprint" to start...</div>
    </div>
    
    <button onclick="generateFingerprint()" style="padding: 10px 20px; font-size: 16px;">Generate Fingerprint</button>
    <button onclick="runCollisionTest()" style="padding: 10px 20px; font-size: 16px; margin-left: 10px;">Run Collision Test (100x)</button>

    <script>
        // Exact functions from DataDome's Worker blob
        function hashData(data) {
            return crypto.subtle.digest("SHA-256", data).then(function(hash) {
                return Array.from(new Uint8Array(hash));
            });
        }

        function toHex(bytes) {
            return bytes.map(function(byte) {
                return byte.toString(16).padStart(2, "0");
            }).join("");
        }

        // Exact text canvas rendering from DataDome
        function renderTextCanvas(canvas, ctx) {
            canvas.width = 380;
            canvas.height = 55;
            ctx.textBaseline = "alphabetic";
            ctx.fillStyle = "#F0A";
            ctx.fillRect(49, 1, 73, 25);
            
            var text = "Quartz glyph job vexd cwm finks" + String.fromCharCode(55357, 56898);
            ctx.fillStyle = "#3A1";
            ctx.font = '13pt "Times New Roman"';
            ctx.fillText(text, 5, 17);
            ctx.fillStyle = "rgba(49, 40, 223, 0.33)";
            ctx.font = "17pt Arial";
            ctx.fillText(text, 7, 25);
        }

        // Exact geometric canvas rendering from DataDome
        function renderGeometricCanvas(canvas, ctx) {
            canvas.width = 131;
            canvas.height = 115;
            ctx.globalCompositeOperation = "multiply";
            
            var circles = [["#E3E", 55, 55], ["#3EE", 95, 55], ["#EE3", 70, 90]];
            for (var i = 0; i < circles.length; i++) {
                ctx.fillStyle = circles[i][0];
                ctx.beginPath();
                ctx.arc(circles[i][1], circles[i][2], 45, 0, 2 * Math.PI, true);
                ctx.closePath();
                ctx.fill();
            }
            
            ctx.fillStyle = "#EA3";
            ctx.arc(65, 65, 65, 0, 2 * Math.PI, true);
            ctx.arc(65, 65, 30, 0, 2 * Math.PI, true);
            ctx.fill("evenodd");
        }

        async function generateFingerprint() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 'Generating fingerprint...';
            
            try {
                // Get canvases
                const textCanvas = document.getElementById('textCanvas');
                const geometricCanvas = document.getElementById('geometricCanvas');
                const textCtx = textCanvas.getContext('2d');
                const geometricCtx = geometricCanvas.getContext('2d');
                
                // Render exactly like DataDome
                renderTextCanvas(textCanvas, textCtx);
                
                // Get first text canvas hash (twice like DataDome does)
                const textImageData1 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                const textImageData2 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                
                renderGeometricCanvas(geometricCanvas, geometricCtx);
                const geometricImageData = geometricCtx.getImageData(0, 0, geometricCanvas.width, geometricCanvas.height);
                
                // Hash all three datasets exactly like DataDome
                const [textHash1, textHash2, geometricHash] = await Promise.all([
                    hashData(textImageData1.data),
                    hashData(textImageData2.data),
                    hashData(geometricImageData.data)
                ]);
                
                // Check for instability (exact DataDome logic)
                const isUnstable = toHex(textHash1) !== toHex(textHash2);
                
                // XOR first text hash with geometric hash (exact DataDome logic)
                const finalHash = textHash1.map(function(byte, index) {
                    return byte ^ geometricHash[index];
                });
                
                // Display results
                const hexFinalHash = toHex(finalHash);
                resultsDiv.innerHTML = `
                    <strong>Canvas Fingerprint (pcso):</strong> ${hexFinalHash}<br>
                    <strong>Stability:</strong> ${isUnstable ? 'UNST (Unstable)' : 'Stable'}<br>
                    <strong>Text Hash 1:</strong> ${toHex(textHash1)}<br>
                    <strong>Text Hash 2:</strong> ${toHex(textHash2)}<br>
                    <strong>Geometric Hash:</strong> ${toHex(geometricHash)}<br>
                    <strong>Text Hashes Match:</strong> ${!isUnstable}
                `;
                
                // Also log to console for easy copying
                console.log('DataDome Picasso Results:');
                console.log('pcso:', hexFinalHash);
                console.log('ch:', isUnstable ? 'UNST' : 'stable');
                
            } catch (error) {
                resultsDiv.innerHTML = 'Error: ' + error.message;
                console.error('Fingerprint generation error:', error);
            }
        }

        // Known DataDome hashes for collision testing
        const knownHashes = [
            "131bd7b5e8f9221c94eb742406b4b47e", "86e105b55c457847c7234ed570e925fe",
            "39114cf3b63d8af324af9c111ba0ea05", "89e095e6a52cc387edd991d82cca2cdc", 
            "24441bba25a6e2916b4eaf01448ec1fa", "70410ed014ce6c7378228456d621ddfd",
            "5486f35f2af0574912576b7e5263a912", "cf03d4d6dc719e59acb1671dc0263e2e",
            "4672bc1c135b989dd64f9fb7ed68e729", "a52d3ff1605eff146016a8a00dd1d5f1",
            "0cf0f9a0da87810220afb839d17f74e2", "17fb98a69e516e34e960f4341bac31ed",
            "71a8c093f45196f2d410de7876b236fc", "8f84d86b9158dbf15d5437bc21092799",
            "297456eaa17442feff9533a7225bfce1", "da8c070dfb173b6a49b66b92f7c111f5",
            "0e0c752173a1dadcd6e8916df7a96dd3", "cb5d6bd6cdc4d8d15ca6dc382e8fc959",
            "0d06aa7ee1c84b08e5b82f180109600f", "b82fb81f9ebdb674059b7417f2e6aea7",
            "570bac3d71aede85ea1de7f21a353fae", "d18f65c302f908c9a49e77f0a471f58a",
            "47bcd2ab1356745c729ccc91133ff5b1", "ca2446e997de712792d5c8bea5740472",
            "a27e44c52234700af6b04825e78f82c1", "ca9a49dbabc48f9e02c66117700a5b40",
            "e6acb86ca2766314aacb8f3fe3fb07d6", "39a957a920b2546289421ee1d98b19c4",
            "8610afe1f088c8186ee34b1a8e3b80f4", "3868d536d2e5fd3ef2272b3cc394debf",
            "ddb7c711d42b35c7ec2fc6b47551adee"
        ];

        async function runCollisionTest() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = 'Running collision test (100 iterations)...<br><br>';
            
            const generatedHashes = [];
            let matches = 0;
            let uniqueHashes = new Set();
            
            for (let i = 0; i < 100; i++) {
                try {
                    const textCanvas = document.getElementById('textCanvas');
                    const geometricCanvas = document.getElementById('geometricCanvas');
                    const textCtx = textCanvas.getContext('2d');
                    const geometricCtx = geometricCanvas.getContext('2d');
                    
                    renderTextCanvas(textCanvas, textCtx);
                    const textImageData1 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                    const textImageData2 = textCtx.getImageData(0, 0, textCanvas.width, textCanvas.height);
                    
                    renderGeometricCanvas(geometricCanvas, geometricCtx);
                    const geometricImageData = geometricCtx.getImageData(0, 0, geometricCanvas.width, geometricCanvas.height);
                    
                    const [textHash1, textHash2, geometricHash] = await Promise.all([
                        hashData(textImageData1.data),
                        hashData(textImageData2.data), 
                        hashData(geometricImageData.data)
                    ]);
                    
                    const isUnstable = toHex(textHash1) !== toHex(textHash2);
                    const finalHash = textHash1.map((byte, index) => byte ^ geometricHash[index]);
                    const hexFinalHash = toHex(finalHash);
                    
                    generatedHashes.push(hexFinalHash);
                    uniqueHashes.add(hexFinalHash);
                    
                    // Check if this hash matches any known DataDome hash
                    if (knownHashes.includes(hexFinalHash)) {
                        matches++;
                        console.log(`🎯 COLLISION FOUND! Iteration ${i+1}: ${hexFinalHash}`);
                    }
                    
                    if ((i + 1) % 10 === 0) {
                        resultsDiv.innerHTML += `Completed ${i+1}/100 iterations. Matches so far: ${matches}<br>`;
                    }
                } catch (error) {
                    console.error(`Error in iteration ${i+1}:`, error);
                }
            }
            
            // Calculate statistics
            const collisionRate = (matches / 100) * 100;
            const uniqueCount = uniqueHashes.size;
            const expectedCollisionProbability = (31 / Math.pow(16, 32)) * 100; // Theoretical
            
            resultsDiv.innerHTML += `
                <br><h3>Collision Test Results:</h3>
                <strong>Matches with known DataDome hashes:</strong> ${matches}/100 (${collisionRate.toFixed(1)}%)<br>
                <strong>Unique hashes generated:</strong> ${uniqueCount}/100<br>
                <strong>Collision rate:</strong> ${((100 - uniqueCount) / 100 * 100).toFixed(1)}% (self-collisions)<br>
                <br>
                ${matches > 0 ? 
                    '<span style="color: green; font-weight: bold;">✅ SUCCESS: Implementation verified by hash collision!</span>' : 
                    '<span style="color: orange;">⚠️ No collisions found - may need more iterations or algorithm differences</span>'}
                <br><br>
                <strong>All generated hashes:</strong><br>
                <div style="max-height: 200px; overflow-y: scroll; font-size: 12px; background: #f8f8f8; padding: 10px;">
                    ${generatedHashes.map((hash, i) => 
                        `${i+1}: ${hash} ${knownHashes.includes(hash) ? '🎯' : ''}`
                    ).join('<br>')}
                </div>
            `;
        }

        // Auto-generate on page load for convenience
        window.addEventListener('load', function() {
            setTimeout(generateFingerprint, 100);
        });
    </script>
</body>
</html>